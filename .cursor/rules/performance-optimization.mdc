---
description: Application performance optimization and monitoring best practices
globs: ["**/*.{ts,tsx,js,jsx,vue}", "**/pages/**/*", "**/components/**/*"]
alwaysApply: false
---

# Performance Optimization: Application Performance Best Practices

**THESE INSTRUCTIONS ARE CRITICAL!**

They ensure fast, responsive, and efficient applications with optimal user experience.

## Performance Protocol

### Image Optimization
```vue
<!-- ✅ Good - Optimized image loading -->
<template>
  <img 
    :src="optimizedImageUrl" 
    :alt="recipe.name"
    loading="lazy"
    decoding="async"
    width="300"
    height="200"
  />
</template>

<script setup lang="ts">
// ✅ Good - Image optimization utilities
const optimizedImageUrl = computed(() => {
  if (!props.recipe.image) return '/images/placeholder.jpg'
  
  // Use Nuxt Image for optimization
  return $image(props.recipe.image, {
    width: 300,
    height: 200,
    format: 'webp',
    quality: 80
  })
})
</script>
```

### Component Lazy Loading
```vue
<!-- ✅ Good - Lazy load heavy components -->
<template>
  <div>
    <LazyRecipeCard 
      v-for="recipe in recipes" 
      :key="recipe.id" 
      :recipe="recipe" 
    />
  </div>
</template>

<script setup lang="ts">
// ✅ Good - Dynamic imports for code splitting
const HeavyComponent = defineAsyncComponent(() => 
  import('~/components/HeavyComponent.vue')
)
</script>
```

### Bundle Optimization
```typescript
// ✅ Good - Tree shaking and code splitting
// nuxt.config.ts
export default defineNuxtConfig({
  build: {
    transpile: ['vue-toastification'],
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['vue', 'pinia'],
          utils: ['lodash-es', 'date-fns']
        }
      }
    }
  },
  
  // ✅ Good - Module optimization
  modules: [
    '@nuxt/image',
    '@nuxtjs/tailwindcss'
  ],
  
  // ✅ Good - Bundle analysis
  nitro: {
    experimental: {
      wasm: true
    }
  }
})
```

### Memory Management
```typescript
// ✅ Good - Proper cleanup in composables
export const useRecipeSearch = () => {
  const searchResults = ref<Recipe[]>([])
  const loading = ref(false)
  const abortController = ref<AbortController | null>(null)
  
  const searchRecipes = async (query: string) => {
    // Cancel previous request
    if (abortController.value) {
      abortController.value.abort()
    }
    
    abortController.value = new AbortController()
    loading.value = true
    
    try {
      const results = await $fetch('/api/recipes/search', {
        params: { q: query },
        signal: abortController.value.signal
      })
      searchResults.value = results
    } catch (error) {
      if (error.name !== 'AbortError') {
        console.error('Search failed:', error)
      }
    } finally {
      loading.value = false
    }
  }
  
  // ✅ Good - Cleanup on unmount
  onUnmounted(() => {
    if (abortController.value) {
      abortController.value.abort()
    }
  })
  
  return {
    searchResults: readonly(searchResults),
    loading: readonly(loading),
    searchRecipes
  }
}
```

### Caching Strategies
```typescript
// ✅ Good - Intelligent caching
export const useRecipeCache = () => {
  const cache = new Map<string, { data: any; timestamp: number }>()
  const CACHE_DURATION = 5 * 60 * 1000 // 5 minutes
  
  const getCachedRecipe = (id: string) => {
    const cached = cache.get(id)
    if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
      return cached.data
    }
    return null
  }
  
  const setCachedRecipe = (id: string, data: any) => {
    cache.set(id, { data, timestamp: Date.now() })
  }
  
  const clearExpiredCache = () => {
    const now = Date.now()
    for (const [key, value] of cache.entries()) {
      if (now - value.timestamp > CACHE_DURATION) {
        cache.delete(key)
      }
    }
  }
  
  return {
    getCachedRecipe,
    setCachedRecipe,
    clearExpiredCache
  }
}
```

### Virtual Scrolling for Large Lists
```vue
<!-- ✅ Good - Virtual scrolling for performance -->
<template>
  <VirtualList
    :items="recipes"
    :item-height="200"
    :container-height="600"
  >
    <template #default="{ item }">
      <RecipeCard :recipe="item" />
    </template>
  </VirtualList>
</template>

<script setup lang="ts">
import { VirtualList } from 'vue-virtual-scroll-list'
</script>
```

### Debouncing and Throttling
```typescript
// ✅ Good - Debounced search
export const useDebouncedSearch = (delay = 300) => {
  const searchQuery = ref('')
  const debouncedQuery = ref('')
  let timeoutId: NodeJS.Timeout | null = null
  
  watch(searchQuery, (newQuery) => {
    if (timeoutId) {
      clearTimeout(timeoutId)
    }
    
    timeoutId = setTimeout(() => {
      debouncedQuery.value = newQuery
    }, delay)
  })
  
  onUnmounted(() => {
    if (timeoutId) {
      clearTimeout(timeoutId)
    }
  })
  
  return {
    searchQuery,
    debouncedQuery: readonly(debouncedQuery)
  }
}

// ✅ Good - Throttled scroll handler
export const useThrottledScroll = (callback: Function, delay = 100) => {
  let lastCall = 0
  
  return (...args: any[]) => {
    const now = Date.now()
    if (now - lastCall >= delay) {
      lastCall = now
      callback(...args)
    }
  }
}
```

### Core Web Vitals Optimization
```vue
<!-- ✅ Good - Optimize for Core Web Vitals -->
<template>
  <div>
    <!-- ✅ Good - Preload critical resources -->
    <link rel="preload" href="/fonts/main.woff2" as="font" type="font/woff2" crossorigin>
    
    <!-- ✅ Good - Optimize above-the-fold content -->
    <div class="hero-section">
      <h1>Discover Amazing Recipes</h1>
      <SearchBar />
    </div>
    
    <!-- ✅ Good - Lazy load below-the-fold content -->
    <div class="recipe-grid">
      <LazyRecipeCard 
        v-for="recipe in visibleRecipes" 
        :key="recipe.id" 
        :recipe="recipe" 
      />
    </div>
  </div>
</template>

<script setup lang="ts">
// ✅ Good - Intersection Observer for lazy loading
const { $intersectionObserver } = useNuxtApp()
const recipeGrid = ref<HTMLElement>()
const visibleRecipes = ref<Recipe[]>([])

onMounted(() => {
  if (recipeGrid.value) {
    $intersectionObserver.observe(recipeGrid.value, (entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          // Load more recipes when grid becomes visible
          loadMoreRecipes()
        }
      })
    })
  }
})
</script>
```

### Performance Monitoring
```typescript
// ✅ Good - Performance monitoring
export const usePerformanceMonitor = () => {
  const metrics = ref({
    fcp: 0, // First Contentful Paint
    lcp: 0, // Largest Contentful Paint
    fid: 0, // First Input Delay
    cls: 0  // Cumulative Layout Shift
  })
  
  const measurePerformance = () => {
    // Measure Core Web Vitals
    if ('PerformanceObserver' in window) {
      // First Contentful Paint
      new PerformanceObserver((list) => {
        const entries = list.getEntries()
        const fcp = entries[entries.length - 1]
        metrics.value.fcp = fcp.startTime
      }).observe({ entryTypes: ['paint'] })
      
      // Largest Contentful Paint
      new PerformanceObserver((list) => {
        const entries = list.getEntries()
        const lcp = entries[entries.length - 1]
        metrics.value.lcp = lcp.startTime
      }).observe({ entryTypes: ['largest-contentful-paint'] })
      
      // First Input Delay
      new PerformanceObserver((list) => {
        const entries = list.getEntries()
        const fid = entries[entries.length - 1]
        metrics.value.fid = fid.processingStart - fid.startTime
      }).observe({ entryTypes: ['first-input'] })
      
      // Cumulative Layout Shift
      new PerformanceObserver((list) => {
        let cls = 0
        for (const entry of list.getEntries()) {
          if (!entry.hadRecentInput) {
            cls += entry.value
          }
        }
        metrics.value.cls = cls
      }).observe({ entryTypes: ['layout-shift'] })
    }
  }
  
  onMounted(() => {
    measurePerformance()
  })
  
  return {
    metrics: readonly(metrics)
  }
}
```

### Bundle Analysis
```typescript
// ✅ Good - Bundle size monitoring
// scripts/analyze-bundle.js
import { build } from 'vite'
import { visualizer } from 'rollup-plugin-visualizer'

export default defineConfig({
  plugins: [
    visualizer({
      filename: 'dist/stats.html',
      open: true,
      gzipSize: true,
      brotliSize: true
    })
  ]
})

// ✅ Good - Package.json scripts
// {
//   "scripts": {
//     "analyze": "nuxt build --analyze",
//     "build:analyze": "ANALYZE=true nuxt build"
//   }
// }
```

## Performance Checklist

### Before Deployment
- [ ] Images optimized and lazy loaded
- [ ] Components code-split appropriately
- [ ] Bundle size under 250KB (gzipped)
- [ ] Core Web Vitals meet targets
- [ ] Caching strategies implemented
- [ ] Memory leaks prevented

### Core Web Vitals Targets
- **LCP (Largest Contentful Paint)**: < 2.5s
- **FID (First Input Delay)**: < 100ms
- **CLS (Cumulative Layout Shift)**: < 0.1

### Monitoring
- [ ] Performance metrics tracked
- [ ] Bundle analysis automated
- [ ] Real User Monitoring (RUM) configured
- [ ] Performance budgets enforced

## Remember

**Always prioritize user experience through fast loading times, smooth interactions, and efficient resource usage. Monitor performance continuously and optimize based on real user data.**

---

*This rule ensures fast, responsive, and efficient applications with optimal user experience.*
