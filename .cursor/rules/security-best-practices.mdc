---
description: Application security standards and vulnerability prevention best practices
globs: ["**/*.ts", "**/*.js", "**/*.vue", "**/server/**/*"]
alwaysApply: false
---

# Security Best Practices: Application Security Standards

**THESE INSTRUCTIONS ARE CRITICAL!**

They ensure secure, robust, and protected applications against common security vulnerabilities.

## Security Protocol

### Input Validation and Sanitization
```typescript
// ✅ Good - Server-side input validation
import { z } from 'zod'
import DOMPurify from 'isomorphic-dompurify'

// ✅ Good - Strict validation schemas
const searchQuerySchema = z.object({
  q: z.string()
    .min(1, 'Search query is required')
    .max(100, 'Search query too long')
    .transform(val => DOMPurify.sanitize(val.trim())),
  page: z.coerce.number()
    .min(1, 'Page must be at least 1')
    .max(100, 'Page number too high')
    .default(1),
  limit: z.coerce.number()
    .min(1, 'Limit must be at least 1')
    .max(50, 'Limit too high')
    .default(12)
})

const createRecipeSchema = z.object({
  name: z.string()
    .min(1, 'Recipe name is required')
    .max(200, 'Recipe name too long')
    .transform(val => DOMPurify.sanitize(val.trim())),
  description: z.string()
    .min(1, 'Description is required')
    .max(1000, 'Description too long')
    .transform(val => DOMPurify.sanitize(val.trim())),
  ingredients: z.array(z.object({
    name: z.string()
      .min(1, 'Ingredient name is required')
      .max(200, 'Ingredient name too long')
      .transform(val => DOMPurify.sanitize(val.trim())),
    amount: z.string()
      .max(50, 'Amount too long')
      .optional()
      .transform(val => val ? DOMPurify.sanitize(val.trim()) : undefined)
  })).min(1, 'At least one ingredient is required')
})

// ✅ Good - API route with validation
export default defineEventHandler(async (event) => {
  const method = getMethod(event)
  
  if (method === 'GET') {
    const query = getQuery(event)
    const validatedQuery = searchQuerySchema.parse(query)
    return await searchRecipes(validatedQuery)
  }
  
  if (method === 'POST') {
    const body = await readBody(event)
    const validatedBody = createRecipeSchema.parse(body)
    return await createRecipe(validatedBody)
  }
})
```

### XSS Prevention
```vue
<!-- ✅ Good - Vue template with XSS prevention -->
<template>
  <div class="recipe-card">
    <!-- ✅ Good - Use v-text for dynamic content -->
    <h3 v-text="recipe.name"></h3>
    
    <!-- ✅ Good - Sanitize HTML content -->
    <p v-html="sanitizedDescription"></p>
    
    <!-- ✅ Good - Use v-bind for attributes -->
    <img :src="recipe.image" :alt="recipe.name" />
    
    <!-- ✅ Good - Avoid inline event handlers -->
    <button @click="handleClick">View Recipe</button>
  </div>
</template>

<script setup lang="ts">
import DOMPurify from 'isomorphic-dompurify'

interface Props {
  recipe: Recipe
}

const props = defineProps<Props>()

// ✅ Good - Sanitize user-generated content
const sanitizedDescription = computed(() => {
  return DOMPurify.sanitize(props.recipe.description || '')
})

// ✅ Good - Safe event handling
const handleClick = () => {
  // Validate and sanitize any user input before processing
  navigateTo(`/recipe/${encodeURIComponent(props.recipe.id)}`)
}
</script>
```

### CSRF Protection
```typescript
// ✅ Good - CSRF token implementation
// server/middleware/csrf.ts
import { createHash, randomBytes } from 'crypto'

export default defineEventHandler(async (event) => {
  const method = getMethod(event)
  
  // Skip CSRF check for GET requests
  if (method === 'GET') {
    return
  }
  
  // Generate CSRF token for forms
  if (method === 'POST' && getRequestURL(event).pathname === '/api/csrf-token') {
    const token = randomBytes(32).toString('hex')
    const hash = createHash('sha256').update(token + process.env.CSRF_SECRET).digest('hex')
    
    setCookie(event, 'csrf-token', hash, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: 3600 // 1 hour
    })
    
    return { token }
  }
  
  // Verify CSRF token for state-changing requests
  if (['POST', 'PUT', 'DELETE', 'PATCH'].includes(method)) {
    const csrfToken = getHeader(event, 'x-csrf-token')
    const cookieToken = getCookie(event, 'csrf-token')
    
    if (!csrfToken || !cookieToken) {
      throw createError({
        statusCode: 403,
        statusMessage: 'CSRF token missing'
      })
    }
    
    const expectedHash = createHash('sha256')
      .update(csrfToken + process.env.CSRF_SECRET)
      .digest('hex')
    
    if (cookieToken !== expectedHash) {
      throw createError({
        statusCode: 403,
        statusMessage: 'Invalid CSRF token'
      })
    }
  }
})

// ✅ Good - Client-side CSRF token handling
// composables/useCsrf.ts
export const useCsrf = () => {
  const csrfToken = ref<string>('')
  
  const fetchCsrfToken = async () => {
    const { data } = await $fetch<{ token: string }>('/api/csrf-token', {
      method: 'POST'
    })
    csrfToken.value = data.token
  }
  
  const requestWithCsrf = async (url: string, options: any = {}) => {
    if (!csrfToken.value) {
      await fetchCsrfToken()
    }
    
    return await $fetch(url, {
      ...options,
      headers: {
        ...options.headers,
        'x-csrf-token': csrfToken.value
      }
    })
  }
  
  return {
    csrfToken: readonly(csrfToken),
    fetchCsrfToken,
    requestWithCsrf
  }
}
```

### Environment Variable Security
```typescript
// ✅ Good - Secure environment variable management
// nuxt.config.ts
export default defineNuxtConfig({
  runtimeConfig: {
    // Private keys (server-side only)
    spoonacularApiKey: process.env.SPOONACULAR_API_KEY,
    databaseUrl: process.env.DATABASE_URL,
    jwtSecret: process.env.JWT_SECRET,
    csrfSecret: process.env.CSRF_SECRET,
    
    // Public keys (exposed to client)
    public: {
      apiBase: process.env.NUXT_PUBLIC_API_BASE,
      appName: process.env.NUXT_PUBLIC_APP_NAME
    }
  }
})

// ✅ Good - Server-side API key usage
// server/api/recipes.ts
export default defineEventHandler(async (event) => {
  const config = useRuntimeConfig()
  const apiKey = config.spoonacularApiKey // Server-side only
  
  if (!apiKey) {
    throw createError({
      statusCode: 500,
      statusMessage: 'API configuration error'
    })
  }
  
  const response = await $fetch('https://api.spoonacular.com/recipes/search', {
    headers: {
      'X-API-Key': apiKey
    }
  })
  
  return response
})
```

### Content Security Policy
```typescript
// ✅ Good - CSP middleware
// server/middleware/csp.ts
export default defineEventHandler(async (event) => {
  const cspDirectives = [
    "default-src 'self'",
    "script-src 'self' 'unsafe-inline' 'unsafe-eval'",
    "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com",
    "font-src 'self' https://fonts.gstatic.com",
    "img-src 'self' data: https:",
    "connect-src 'self' https://api.spoonacular.com",
    "frame-ancestors 'none'",
    "base-uri 'self'",
    "form-action 'self'"
  ].join('; ')
  
  setResponseHeaders(event, {
    'Content-Security-Policy': cspDirectives,
    'X-Content-Type-Options': 'nosniff',
    'X-Frame-Options': 'DENY',
    'X-XSS-Protection': '1; mode=block',
    'Referrer-Policy': 'strict-origin-when-cross-origin'
  })
})
```

### SQL Injection Prevention
```typescript
// ✅ Good - Parameterized queries with Prisma
export async function searchRecipes(filters: RecipeFilters) {
  return await prisma.recipe.findMany({
    where: {
      AND: [
        filters.search ? {
          OR: [
            { name: { contains: filters.search, mode: 'insensitive' } },
            { description: { contains: filters.search, mode: 'insensitive' } }
          ]
        } : {},
        filters.cuisine ? { cuisine: filters.cuisine } : {}
      ]
    },
    include: {
      ingredients: true,
      nutrition: true
    }
  })
}

// ❌ Bad - Never use raw SQL with user input
// const query = `SELECT * FROM recipes WHERE name LIKE '%${userInput}%'`
```

### Rate Limiting
```typescript
// ✅ Good - Rate limiting implementation
// server/middleware/rate-limit.ts
import { LRUCache } from 'lru-cache'

const rateLimitCache = new LRUCache({
  max: 1000,
  ttl: 1000 * 60 * 15 // 15 minutes
})

export default defineEventHandler(async (event) => {
  const clientIp = getClientIP(event) || 'unknown'
  const key = `rate-limit:${clientIp}`
  
  const current = rateLimitCache.get(key) as number || 0
  
  if (current >= 100) { // 100 requests per 15 minutes
    throw createError({
      statusCode: 429,
      statusMessage: 'Too many requests'
    })
  }
  
  rateLimitCache.set(key, current + 1)
})
```

### Authentication and Authorization
```typescript
// ✅ Good - JWT token validation
// server/middleware/auth.ts
import jwt from 'jsonwebtoken'

export default defineEventHandler(async (event) => {
  const config = useRuntimeConfig()
  const authHeader = getHeader(event, 'authorization')
  
  if (!authHeader?.startsWith('Bearer ')) {
    throw createError({
      statusCode: 401,
      statusMessage: 'Missing authorization header'
    })
  }
  
  const token = authHeader.substring(7)
  
  try {
    const decoded = jwt.verify(token, config.jwtSecret)
    event.context.user = decoded
  } catch (error) {
    throw createError({
      statusCode: 401,
      statusMessage: 'Invalid token'
    })
  }
})

// ✅ Good - Role-based authorization
export function requireRole(role: string) {
  return defineEventHandler(async (event) => {
    const user = event.context.user
    
    if (!user || user.role !== role) {
      throw createError({
        statusCode: 403,
        statusMessage: 'Insufficient permissions'
      })
    }
  })
}
```

### Secure File Uploads
```typescript
// ✅ Good - Secure file upload handling
// server/api/upload.ts
import { writeFile, mkdir } from 'fs/promises'
import { extname, join } from 'path'

const allowedTypes = ['image/jpeg', 'image/png', 'image/webp']
const maxSize = 5 * 1024 * 1024 // 5MB

export default defineEventHandler(async (event) => {
  const formData = await readMultipartFormData(event)
  
  if (!formData) {
    throw createError({
      statusCode: 400,
      statusMessage: 'No file uploaded'
    })
  }
  
  const file = formData.find(item => item.name === 'file')
  
  if (!file) {
    throw createError({
      statusCode: 400,
      statusMessage: 'No file found'
    })
  }
  
  // Validate file type
  if (!allowedTypes.includes(file.type)) {
    throw createError({
      statusCode: 400,
      statusMessage: 'Invalid file type'
    })
  }
  
  // Validate file size
  if (file.data.length > maxSize) {
    throw createError({
      statusCode: 400,
      statusMessage: 'File too large'
    })
  }
  
  // Generate secure filename
  const extension = extname(file.filename || '')
  const filename = `${crypto.randomUUID()}${extension}`
  const uploadDir = join(process.cwd(), 'public', 'uploads')
  
  // Ensure upload directory exists
  await mkdir(uploadDir, { recursive: true })
  
  // Save file
  const filepath = join(uploadDir, filename)
  await writeFile(filepath, file.data)
  
  return {
    success: true,
    filename: `/uploads/${filename}`
  }
})
```

### Security Headers
```typescript
// ✅ Good - Security headers middleware
// server/middleware/security-headers.ts
export default defineEventHandler(async (event) => {
  setResponseHeaders(event, {
    'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
    'X-Content-Type-Options': 'nosniff',
    'X-Frame-Options': 'DENY',
    'X-XSS-Protection': '1; mode=block',
    'Referrer-Policy': 'strict-origin-when-cross-origin',
    'Permissions-Policy': 'camera=(), microphone=(), geolocation=()'
  })
})
```

## Remember

**Always validate and sanitize user input, implement proper authentication and authorization, use HTTPS in production, and follow the principle of least privilege. Never trust user input and always use parameterized queries.**

---

*This rule ensures secure, robust, and protected applications against common security vulnerabilities.*
description:
globs:
alwaysApply: false
---
